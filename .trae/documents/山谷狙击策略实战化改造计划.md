# 📉 山谷狙击策略 V2.0 终极实施规格书 (Final + Trade Date)

您的严谨令人敬佩。**非交易日 (Weekends/Holidays)** 确实是时间源逻辑的盲区。若仅依赖系统时间，在周六运行时会凭空合成一根“周六 K 线”（实为周五副本），导致数据污染。

我们引入 **“交易日历锚点”** 来彻底解决此问题：

---

## 1. 工程底座 (Foundation)

### 1.1 全局锚点：`CURRENT_TRADE_DATE`
- **获取时机**: 脚本启动时（Map 阶段之前），只获取一次。
- **方法**: 调用 `ak.tool_trade_date_hist_sina()` 获取最近的一个交易日。
- **作用**: 作为全脚本的**“时间真理”**，替代 `datetime.now()`。

### 1.2 核心算法：`synthesize_realtime_data` (含交易日校验)
- **输入**: `hist_df`, `spot_row`, `current_trade_date` (Global Anchor)。
- **校验逻辑**:
  1. 获取 `hist_df` 最后一行的日期 `last_hist_date`。
  2. **判定**:
     - **若 `last_hist_date >= current_trade_date`**: 说明历史数据已是最新的（或今天是周六，历史数据停在周五，两者相等），**直接返回**，不进行合成。
     - **若 `last_hist_date < current_trade_date`**: 说明存在 T+0 缺口（今天是交易日且收盘后历史库未更新，或盘中），执行合成。
  3. **合成日期**: 新行的日期强制设为 `current_trade_date`，而非系统时间。

---

## 2. Map 阶段：极速清洗

- **实现**: Pandas 向量化布尔索引。
- **规则**: 剔除 BJ/ST，锁定 `1% < 换手率 < 15%`，`Abs(Pct) < 9%`。

---

## 3. Reduce 阶段：深度策略

- **IBS 边界保护**: `if High == Low: IBS = 0.5`。
- **双重成本确认**: VWAP + BIAS。
- **Regime Filter**: 动态调整阈值。

---

## 4. 交付清单

我们将创建 `backend/scripts/valley_sniper_v2.py`，流程如下：
1.  **Init**: 获取 `current_trade_date`。
2.  **Map**: 获取 Snapshot 并初筛。
3.  **Reduce**: 并发执行 `process_stock(code, snapshot_row, current_trade_date)`。
    - 内部调用 `synthesize` (带日期校验)。
    - 内部计算指标 (IBS/VWAP/MACD)。

现在，逻辑已滴水不漏。Start Coding。