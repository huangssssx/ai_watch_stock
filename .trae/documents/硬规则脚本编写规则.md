# 硬规则脚本编写规则

本文用于指导用户编写“硬规则脚本（Hard Rules）”。硬规则脚本会在盯盘任务中被执行，用于输出明确的交易信号（买入/卖出/观望等）与解释文本，并可用于触发告警。

## 1. 运行模型与基本约束

- 脚本通过 `exec()` 执行，运行时会注入若干变量（见下文）。
- 脚本应当是“纯计算 + 产出信号”的逻辑块：不要读写文件、不要访问数据库、不要发网络请求到非行情源（除非你明确知道后果）。
- 脚本执行期间 `print()` 的输出会被捕获，并写入日志，用于调试。
- 性能建议：脚本应尽量在秒级完成；避免不必要的大量历史回测、循环拉取行情等操作。

## 2. 注入变量（输入）

执行时可直接使用以下变量（无需 `import`）：

- `symbol`：股票代码字符串（例如 `"sh600000"`、`"sz000001"`、`"bjXXXXXX"`，也可能是无前缀的 `"600000"`）
- `ak`：AkShare 模块
- `pd`：pandas 模块
- `np`：numpy 模块
- `datetime`：datetime 模块
- `time`：time 模块
- `triggered`：默认 `False`，由脚本改写（见输出契约）
- `message`：默认空字符串或提示语，由脚本改写（见输出契约）
- `signal`：建议脚本显式设置（见输出契约）

## 3. 输出契约（必须遵守）

脚本需要通过修改变量来“返回”结果。核心是三个变量：

### 3.1 `triggered`（是否触发）

- 类型：`bool`
- 含义：本次是否触发“硬规则事件”。
- 重要：在当前引擎实现中，`triggered=False` 时本次规则会被视为“未触发”，不会进入后续信号/告警流程。
  - `script_only`（仅脚本）模式：`triggered=False` 会直接跳过，不会产生 BUY/SELL/WAIT 的结果输出。
  - `hybrid`（脚本+AI）模式：同样需要 `triggered=True` 才会进入后续流程。

### 3.2 `signal`（信号方向/强度）

- 类型：`str`
- 建议值（规范写法，强烈推荐使用以下大写枚举）：
  - `"BUY"`：买入
  - `"SELL"`：卖出
  - `"WAIT"`：观望
  - `"STRONG_BUY"`：强烈买入
  - `"STRONG_SELL"`：强烈卖出
- 兼容性：如果你不设置 `signal` 但设置了 `triggered=True`，系统会在部分路径下回退为 `"BUY"`。为了避免误判，务必显式设置 `signal`。

### 3.3 `message`（解释文本）

- 类型：`str`
- 用途：展示给前端/日志/告警，帮助理解为何触发该信号。
- 建议：
  - 尽量短（1～3 行），包含关键指标值与阈值对比
  - 不要包含敏感信息（API Key、账户信息等）

## 4. 推荐的脚本结构（模板）

```python
triggered = False
signal = "WAIT"
message = "监控中：等待条件..."

try:
    # 1) 处理 symbol（可选）
    symbol_code = symbol
    if symbol.startswith(("sh", "sz", "bj")):
        symbol_code = symbol[2:]

    # 2) 拉取/计算指标（示例：按需替换）
    now = datetime.datetime.now()
    start_dt = (now - datetime.timedelta(days=60)).strftime("%Y%m%d")
    end_dt = (now - datetime.timedelta(days=1)).strftime("%Y%m%d")
    df = ak.stock_zh_a_hist(symbol=symbol_code, period="daily", start_date=start_dt, end_date=end_dt, adjust="qfq")

    if df is None or df.empty:
        message = "未触发：历史数据为空"
    else:
        # 3) 规则判断（示例：按需替换）
        # buy_condition = ...
        # sell_condition = ...

        if sell_condition:
            triggered = True
            signal = "SELL"
            message = "触发卖出：xxx"
        elif buy_condition:
            triggered = True
            signal = "BUY"
            message = "触发买入：xxx"
        else:
            message = "未触发：条件不足"

except Exception as e:
    triggered = False
    signal = "WAIT"
    message = f"错误：{str(e)}"
```

## 5. 常见写法与最佳实践

- 先初始化：开头就设置 `triggered=False`、`signal="WAIT"`、`message=...`，避免异常时变量未定义。
- 明确优先级：当买入和卖出条件可能同时满足时，建议先判定 `SELL` 再判定 `BUY`（防止持仓时“该卖却买”）。
- 处理数据空值：AkShare 返回空表/缺列/NaN 很常见，先做 `None/empty` 判断，并对数值列 `pd.to_numeric(..., errors="coerce")`。
- 避免“隐式 BUY”：
  - 只要你设置了 `triggered=True`，就必须同步设置 `signal` 为你真实想表达的方向（尤其是卖出）。
- 用 `print()` 输出调试信息：
  - `print()` 会进入脚本日志，但不要刷屏，建议只在关键分支打印 1～3 行摘要。
- 不要在脚本里做长期循环/睡眠：引擎会定期调用脚本；脚本内部 `time.sleep()` 会拖慢整个盯盘任务。

## 6. 信号选择建议

- 观望但需要留痕：如果你希望“观望也记录下来”，目前引擎要求 `triggered=True` 才会进入输出/告警链路。你可以采用：
  - `triggered=True` + `signal="WAIT"` + `message="观望：xxx"`
  - 同时在告警配置中把 `WAIT` 排除，避免刷屏
- 卖出信号：使用 `signal="SELL"` 或 `signal="STRONG_SELL"`，并给出原因（破位、止损、量能衰竭等）。

## 7. 示例：卖出优先的最小脚本

```python
triggered = False
signal = "WAIT"
message = "监控中..."

try:
    if should_sell:
        triggered = True
        signal = "SELL"
        message = "触发卖出：跌破关键均线"
    elif should_buy:
        triggered = True
        signal = "BUY"
        message = "触发买入：放量突破"
    else:
        message = "未触发：继续等待"
except Exception as e:
    triggered = False
    signal = "WAIT"
    message = f"错误：{str(e)}"
```

