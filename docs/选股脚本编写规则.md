脚本编写规范（AI Watch Stock）
本文档面向系统内三类脚本：
1）选股脚本（选股页面 / Screener）
2）盯盘硬规则脚本（规则库 / Stock Rule Script）
3）指标脚本（指标库 / Indicator：纯脚本或后处理脚本）

0. 通用约定（所有脚本都适用）
● 脚本都是“可直接执行”的 Python 代码片段，不需要定义函数/类。
● 避免长时间阻塞、死循环、超大结果集；尽量保证单次执行快速完成。
● 对外部数据（尤其是 akshare）务必做健壮性处理：判空、列存在性检查、数值转化、NaN 处理。
● 用 print(...) 输出调试信息；系统会收集日志并展示（不同模块收集方式略有差异）。

1) 选股脚本（Screener Page）编写规范
1.1 执行环境（你能直接用的变量）
选股脚本通过后端 exec() 执行，默认注入：
● ak：akshare
● pd：pandas
● datetime：Python datetime 模块
● print：已被系统替换为“写入日志缓冲”的版本（你 print 的内容会出现在运行日志里）
注意：
● 选股脚本没有“逐只股票”的上下文，不会自动提供 symbol。
● 选股脚本不会做任何模板/占位符渲染（例如不会自动替换 {symbol}、{{symbol}}）。
1.2 输出（产出“结果表/报告”的硬性要求）
脚本结束时必须在全局作用域暴露以下二选一变量作为结果：
● df：推荐 pandas.DataFrame
● 或 result：list[dict]
系统取值优先级：
1. 若存在 df：
  ○ df 是 DataFrame：会转换成 JSON records（每行一个 dict）作为结果
  ○ df 是 list：会直接当作结果使用
2. 否则若存在 result：直接当作结果使用
3. 若两者都没有：结果为空，并在日志中给出 warning
1.3 “一键加入监控（Watch）”字段规范（强烈建议遵守）
选股结果表中，如果你希望前端“Watch”按钮能把该行加入监控列表，请保证每行至少包含：
● 股票代码字段：以下任意一个 key（推荐用 symbol）
  ○ symbol / 代码 / 股票代码
● 股票名称字段（可选但推荐）：
  ○ name / 名称 / 股票名称
建议你统一使用：
● symbol：如 "000001" 或 "920662"（保持与项目现有格式一致）
● name：如 "平安银行"
1.4 结果集体量与性能约束（非常重要）
● 前端预览最多只会展示前 100 行，但后端会把全量结果写入数据库。
● 结果过大会导致：
  ○ 存库膨胀、接口慢
  ○ 前端渲染卡顿甚至卡死（表格列多/字符串长更明显）
建议规范：
● 行数：尽量控制在 <= 300（更推荐 <= 100）
● 列数：只保留“决策必要字段”
● 长文本列：限制长度（例如原因/日志摘要最多 200 字）
1.5 推荐输出字段（让结果更像“报告”）
每行建议包含：
● symbol：股票代码（必备）
● name：名称（推荐）
● score：排序分/评分（推荐）
● reason：入选原因（推荐，短句）
● data_mode：数据模式（可选，如 RealTime/History）
● 关键指标列：如 当前价、换手率%、成交额、Alpha 等（按策略需要）
1.6 健壮性写法规范（避免 0 结果/全异常）
建议每份脚本都包含：
● 判空：df is None or df.empty
● 列检查：if "成交额" not in df.columns: ...
● 数值清洗：pd.to_numeric(..., errors="coerce") + dropna
● 时段差异处理：开盘前/竞价/盘中/盘后字段可能 NaN/0，过滤条件要分时段或降级处理
● 异常兜底：顶层 try/except，失败时 print(traceback) 并给空结果（避免系统报错）
1.7 选股脚本骨架（可复制）
import pandas as pd
import traceback
import datetime

print("开始运行选股策略...")

result_rows = []

try:
    # 1) 拉取数据（示例：全市场快照）
    df_spot = ak.stock_zh_a_spot_em()
    if df_spot is None or df_spot.empty:
        print("无数据：df_spot 为空")
    else:
        # 2) 字段检查/清洗（按你的策略改）
        required_cols = ["代码", "名称"]
        missing = [c for c in required_cols if c not in df_spot.columns]
        if missing:
            print("缺少必要列:", missing)
        else:
            # 3) 策略过滤/打分（按你的策略改）
            df_work = df_spot.copy()

            # 举例：只取前 2000 行，避免极端情况下结果过大
            df_work = df_work.head(2000)

            # 4) 组装结果（推荐统一输出 symbol/name）
            for _, row in df_work.head(50).iterrows():
                symbol = str(row["代码"]).strip()
                name = str(row["名称"]).strip()
                result_rows.append({
                    "symbol": symbol,
                    "name": name,
                    "score": 0,
                    "reason": "示例入选",
                })

except Exception as e:
    print("脚本异常:", str(e))
    print(traceback.format_exc())

# 5) 输出：df 或 result 二选一
df = pd.DataFrame(result_rows)
print(f"完成：共 {len(df)} 条结果")
