å±±è°·ç‹™å‡»é€‰è‚¡|# å±±è°·ç‹™å‡»é€‰è‚¡ç­–ç•¥ - v8.6 ä¿®å¤ç‰ˆ
# æ ¸å¿ƒä¿®å¤ï¼šVWAP å•ä½æ•°é‡çº§é”™è¯¯ (Bug Fix)
# ç›®æ ‡ï¼šä¿®æ­£æˆäº¤é‡å•ä½(æ‰‹/è‚¡)å¯¼è‡´çš„ VWAP è™šé«˜ 100 å€é—®é¢˜ï¼Œæ¢å¤ç­–ç•¥æœºèƒ½

import akshare as ak
import pandas as pd
import numpy as np
import datetime
import talib
from scipy.signal import argrelextrema
import warnings
import time

warnings.filterwarnings('ignore')

# --- å‚æ•°é…ç½® ---
RECENT_VOLUME_DAYS = 5
VOLUME_BASE_DAYS = 400
CAP_SMALL = 100 * 1e8
CAP_LARGE = 500 * 1e8
MIN_TURNOVER_AMOUNT = 30000000
MAX_PRICE_CHANGE = 8.0
PRICE_THRESHOLD_MIN_PRICE = 4.0

THRESHOLD_HIGH_QUALITY = 8
THRESHOLD_POTENTIAL = 5

VOL_RANK_MID = 0.15
AR_SPREAD_WINDOW = 20
DRAWDOWN_THRESHOLD = 0.20

MAX_SCORE_ALPHA = 4.0
MAX_SCORE_DRAGON = 3.0

SCORE_CRITERIA = {
    "volume_extreme": 3,
    "macd_div": 3,
    "rsi_div": 2,
    "illiq_composite": 2,
    "sector_fund_flow_strong": 3, 
    "sector_fund_flow_ok": 1,
    "vwap_support": 2,
    "trend_protect": 1,
    "heat_penalty": -3,
    "heat_reversal": 2,
}

# --- æ ¸å¿ƒå‡½æ•° ---

def _safe_vwap(amount_series, vol_series, price_series):
    """
    è‡ªé€‚åº”è®¡ç®— VWAPï¼Œè‡ªåŠ¨ä¿®æ­£ 'æ‰‹' vs 'è‚¡' çš„å•ä½é—®é¢˜
    """
    if len(amount_series) == 0: return 0.0
    
    # å°è¯•1: ç›´æ¥é™¤
    raw_vwap = amount_series.sum() / (vol_series.sum() + 1e-9)
    current_p = price_series.iloc[-1]
    
    # æ£€æŸ¥æ•°é‡çº§å·®å¼‚
    if current_p > 0:
        ratio = raw_vwap / current_p
        if 80 < ratio < 120: # åå·®çº¦100å€ï¼Œè¯´æ˜ Volume æ˜¯æ‰‹
            return raw_vwap / 100.0
        elif 0.8 < ratio < 1.2: # åå·®ä¸å¤§ï¼Œè¯´æ˜ Volume æ˜¯è‚¡
            return raw_vwap
            
    # å…œåº•ï¼šå¦‚æœæ— æ³•åˆ¤æ–­ï¼Œå‡è®¾æ˜¯æ‰‹ï¼ˆAè‚¡é€šå¸¸è¿”å›æ‰‹ï¼‰
    # ä½†ä¸ºäº†ä¿é™©ï¼Œè¿˜æ˜¯è¿”å›ä¿®æ­£åçš„
    return raw_vwap / 100.0 if raw_vwap > current_p * 50 else raw_vwap

def _kalman_filter_1d(values: pd.Series, q: float = 1e-5, r_scale: float = 0.20):
    v = pd.to_numeric(values, errors="coerce").to_numpy(dtype=float)
    if v.size == 0: return values
    first_finite_idx = int(np.argmax(np.isfinite(v))) if np.isfinite(v).any() else None
    if first_finite_idx is None: return values
    dv = np.diff(v[np.isfinite(v)])
    base_var = float(np.nanvar(dv)) if dv.size else 0.1
    r = max(1e-9, r_scale * base_var)
    x = float(v[first_finite_idx])
    p = 1.0
    out = np.empty_like(v, dtype=float)
    out[:] = np.nan
    for i in range(first_finite_idx, v.size):
        if np.isfinite(v[i]):
            p = p + q
            k = p / (p + r)
            x = x + k * (v[i] - x)
            p = (1.0 - k) * p
            out[i] = x
    return pd.Series(out, index=values.index)

def _get_bb_troughs(series: pd.Series, window: int = 5):
    data = series.values
    local_mins = argrelextrema(data, np.less, order=window)[0]
    refined = []
    if len(local_mins) > 0:
        refined.append(local_mins[0])
        for i in range(1, len(local_mins)):
            if local_mins[i] - refined[-1] >= window:
                refined.append(local_mins[i])
            else:
                if data[local_mins[i]] < data[refined[-1]]:
                    refined[-1] = local_mins[i]
    return refined

def detect_dynamic_divergence(smooth_p: pd.Series, indicator: pd.Series):
    if len(smooth_p) < 60: return False
    troughs = _get_bb_troughs(smooth_p)
    if len(troughs) < 2: return False
    last_idx = troughs[-1]
    prev_idx = troughs[-2]
    if (len(smooth_p) - 1) - last_idx > 15: return False
    p_last, p_prev = smooth_p.iloc[last_idx], smooth_p.iloc[prev_idx]
    i_last, i_prev = indicator.iloc[last_idx], indicator.iloc[prev_idx]
    if p_last <= p_prev * 1.02 and i_last > i_prev * 1.05:
        if indicator.iloc[-1] > indicator.iloc[-2]: return True
    return False

def check_overhead_supply(close, volume, amount, current_price):
    if len(close) < 250: return False
    
    # ä¿®å¤ VWAP è®¡ç®—
    vol_20 = volume.rolling(20).sum()
    amt_20 = amount.rolling(20).sum()
    
    # ä½¿ç”¨è‡ªé€‚åº”å‡½æ•°è®¡ç®—å½“å‰çš„ 20æ—¥ VWAP
    # æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥å–æœ€åä¸€å¤©çš„æ•°æ®è¿›è¡Œè‡ªé€‚åº”åˆ¤æ–­
    vwap_20_val = _safe_vwap(amt_20.iloc[-20:], vol_20.iloc[-20:], close.iloc[-20:])
    
    # å®½æ¾æ£€æŸ¥ï¼šå…è®¸è·Œç ´ 20æ—¥çº¿ï¼Œä½†ä¸èƒ½åç¦»å¤ªè¿œ (0.85)
    # v8.5 Bug: ä¹‹å‰ç®—å‡ºæ¥ vwap åå¤§100å€ï¼Œå¯¼è‡´è¿™é‡Œå¿…æŒ‚
    if current_price < vwap_20_val * 0.85: 
        return False
        
    high_52w = close.rolling(250).max().iloc[-1]
    drawdown = (high_52w - current_price) / high_52w
    return drawdown > DRAWDOWN_THRESHOLD

def calculate_alpha54(open_s, high_s, low_s, close_s):
    o = pd.to_numeric(open_s, errors="coerce")
    h = pd.to_numeric(high_s, errors="coerce")
    l = pd.to_numeric(low_s, errors="coerce")
    c = pd.to_numeric(close_s, errors="coerce")
    denom = (l - h).replace(0, -0.01)
    term1 = (l - c) / denom
    term2 = (o / c) ** 5
    alpha = -1.0 * term1 * term2
    curr = alpha.iloc[-1]
    hist = alpha.iloc[-60:].dropna()
    if len(hist) < 30: return 0, 0
    rank = (hist <= curr).mean()
    score = 0
    if rank > 0.5:
        score = ((rank - 0.5) / 0.5) * MAX_SCORE_ALPHA
    return score, rank

def calculate_long_term_vwap(amount, volume, current_price):
    if len(amount) < 300: return 0, 0, 0
    
    # ä¿®å¤ VWAP è®¡ç®—
    vwap_300 = _safe_vwap(amount.iloc[-300:], volume.iloc[-300:], pd.Series([current_price]))
    
    dist_pct = (current_price - vwap_300) / vwap_300
    score = 0
    if -0.15 <= dist_pct <= 0.05:
        score = SCORE_CRITERIA["vwap_support"]
    return score, vwap_300, dist_pct

def dynamic_volume_score(volume, mkt_cap):
    if len(volume) < 120: return 0, 0
    threshold = VOL_RANK_MID
    if mkt_cap > CAP_LARGE: threshold = 0.25
    elif mkt_cap < CAP_SMALL: threshold = 0.10
    curr_vol = volume.iloc[-RECENT_VOLUME_DAYS:].mean()
    hist_vol = volume.iloc[-120:]
    vol_rank = (hist_vol <= curr_vol).mean()
    if vol_rank < threshold: return SCORE_CRITERIA["volume_extreme"], vol_rank
    return 0, vol_rank

# --- ä¸»ç¨‹åº ---
print("ğŸ¯ ã€å±±è°·ç‹™å‡»é€‰è‚¡ç­–ç•¥ v8.6 (Bugä¿®å¤ç‰ˆ)ã€‘å¯åŠ¨")
print("ğŸ› ï¸ ä¿®å¤å†…å®¹ï¼šVWAP å•ä½æ•°é‡çº§è‡ªåŠ¨ä¿®æ­£")
print("ğŸ“¡ æ­£åœ¨è·å–å¸‚åœºæ•°æ®...")

try:
    df_market = ak.stock_zh_a_spot_em()
except Exception as e:
    print(f"âŒ è·å–è¡Œæƒ…å¤±è´¥: {e}")
    df_market = pd.DataFrame()

if not df_market.empty:
    df_market = df_market[~df_market["åç§°"].str.contains("ST|é€€", na=False)]
    df_market = df_market[abs(df_market["æ¶¨è·Œå¹…"]) <= MAX_PRICE_CHANGE]
    if "æˆäº¤é¢" in df_market.columns:
        df_market = df_market[df_market["æˆäº¤é¢"] >= MIN_TURNOVER_AMOUNT]
    if "æœ€æ–°ä»·" in df_market.columns:
        df_market["æœ€æ–°ä»·"] = pd.to_numeric(df_market["æœ€æ–°ä»·"], errors="coerce")
        df_market = df_market[df_market["æœ€æ–°ä»·"] >= PRICE_THRESHOLD_MIN_PRICE]
    
    if "æ¢æ‰‹ç‡" in df_market.columns:
         df_scan = df_market[(df_market["æ¢æ‰‹ç‡"] > 0.8) & (df_market["æ¢æ‰‹ç‡"] < 12.0)]
         df_scan = df_scan.sort_values(by="æˆäº¤é¢", ascending=False).head(500)
    else:
         df_scan = df_market.head(500)

    print(f"ğŸ” æ·±åº¦æ‰«ææ± : {len(df_scan)} åªï¼Œæ­£åœ¨æŒ–æ˜...")

    sector_fund_flow_map = {}
    try:
        fund_flow_df = ak.stock_sector_fund_flow_rank(indicator="5æ—¥", sector_type="è¡Œä¸šèµ„é‡‘æµ")
        if fund_flow_df is not None and not fund_flow_df.empty:
            for _, r in fund_flow_df.iterrows():
                sector_fund_flow_map[str(r["åç§°"])] = float(r["5æ—¥ä¸»åŠ›å‡€æµå…¥-å‡€å æ¯”"])
    except: pass
    
    sector_change_map = {} 
    hot_rank_map = {}
    try:
        hot_df = ak.stock_hot_rank_em()
        if hot_df is not None:
             for _, r in hot_df.iterrows():
                code = str(r["ä»£ç "])
                if len(code) >= 8: code = code[2:]
                hot_rank_map[code] = int(r["å½“å‰æ’å"])
    except: pass

    industry_cache = {}
    def _get_industry(symbol):
        if symbol in industry_cache: return industry_cache[symbol]
        try:
            info = ak.stock_individual_info_em(symbol=symbol)
            ind = info[info["item"]=="è¡Œä¸š"]["value"].iloc[0]
            industry_cache[symbol] = ind
            return ind
        except: return None

    end_date = datetime.datetime.now()
    start_date = end_date - datetime.timedelta(days=VOLUME_BASE_DAYS + 60)
    start_date_str = start_date.strftime("%Y%m%d")
    end_date_str = end_date.strftime("%Y%m%d")
    
    results = []
    skipped_sector = 0
    rescued_dragon = 0
    
    if "æ¶¨è·Œå¹…" in df_scan.columns:
        for idx, row in df_scan.iterrows():
            symbol = str(row["ä»£ç "])[2:] if len(str(row["ä»£ç "]))>=8 else str(row["ä»£ç "])
            ind = _get_industry(symbol)
            if ind:
                if ind not in sector_change_map: sector_change_map[ind] = []
                sector_change_map[ind].append(float(row["æ¶¨è·Œå¹…"]))
    
    sector_median_change = {k: np.median(v) for k, v in sector_change_map.items()}

    for idx, row in df_scan.iterrows():
        raw_symbol = str(row["ä»£ç "])
        symbol = raw_symbol[2:] if len(raw_symbol) >= 8 else raw_symbol
        name = row["åç§°"]
        current_price = float(row["æœ€æ–°ä»·"])
        pct_chg = float(row["æ¶¨è·Œå¹…"])
        mkt_cap = float(row["æµé€šå¸‚å€¼"]) if "æµé€šå¸‚å€¼" in row else 100e8
        
        snapshot_amount = float(row["æˆäº¤é¢"]) if "æˆäº¤é¢" in row else 0
        hot_rank = hot_rank_map.get(symbol, 9999)
        
        industry = _get_industry(symbol)
        ind_change = sector_median_change.get(industry, -1.0)
        
        dragon_score = 0
        is_dragon = False
        if snapshot_amount > 5 * 1e8 and (pct_chg - ind_change > 0):
            is_dragon = True
            capped_amt = min(snapshot_amount, 20 * 1e8) 
            amt_score = 1.0 + (capped_amt - 5e8) / (15e8) * (MAX_SCORE_DRAGON - 1.0)
            dragon_score = max(dragon_score, amt_score)
        elif mkt_cap > 300 * 1e8:
            is_dragon = True
            capped_cap = min(mkt_cap, 2000 * 1e8)
            cap_score = 1.0 + (capped_cap - 300e8) / (1700e8) * (MAX_SCORE_DRAGON - 1.0)
            dragon_score = max(dragon_score, cap_score)
            
        sector_score = 0
        sector_msg = ""
        should_skip = False
        if industry and industry in sector_fund_flow_map:
            ff = sector_fund_flow_map[industry]
            if ff < -5.0:
                if is_dragon:
                    rescued_dragon += 1
                else:
                    should_skip = True
                    skipped_sector += 1
            if not should_skip:
                if ff >= 0.5:
                    sector_score = SCORE_CRITERIA["sector_fund_flow_strong"]
                    sector_msg = f"æ¿å—å¼º({industry})"
                elif ff > 0:
                    sector_score = SCORE_CRITERIA["sector_fund_flow_ok"]
                    sector_msg = f"æ¿å—æ­£({industry})"
        
        if should_skip: continue
        
        if idx % 50 == 0:
            print(f"âš¡ æ‰«æä¸­... å·²ç†”æ–­ {skipped_sector} åªæ‚æ¯›ï¼Œè±å… {rescued_dragon} åªé¾™å¤´")

        try:
            df_hist = ak.stock_zh_a_hist(symbol=symbol, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="qfq")
            if df_hist is None or len(df_hist) < 300: continue
            
            close = pd.to_numeric(df_hist["æ”¶ç›˜"], errors="coerce")
            open_ = pd.to_numeric(df_hist["å¼€ç›˜"], errors="coerce")
            high = pd.to_numeric(df_hist["æœ€é«˜"], errors="coerce")
            low = pd.to_numeric(df_hist["æœ€ä½"], errors="coerce")
            volume = pd.to_numeric(df_hist["æˆäº¤é‡"], errors="coerce")
            amount = pd.to_numeric(df_hist["æˆäº¤é¢"], errors="coerce")
            
            if not check_overhead_supply(close, volume, amount, current_price): continue
            
            ma60 = close.rolling(60).mean()
            if len(ma60) > 0 and ma60.iloc[-1] > 0:
                if current_price < ma60.iloc[-1] * 0.85:
                    continue 
            
            score = sector_score
            signals = []
            if sector_msg: signals.append(sector_msg)
            
            if is_dragon and sector_score == 0:
                score += dragon_score
                signals.append(f"é€†åŠ¿é¾™å¤´({dragon_score:.1f})")

            if current_price > ma60.iloc[-1]:
                score += SCORE_CRITERIA["trend_protect"]
            
            alpha_score, alpha_rank = calculate_alpha54(open_, high, low, close)
            if alpha_score > 0:
                score += alpha_score
                signals.append(f"Alpha54({int(alpha_rank*100)}%|{alpha_score:.1f})")
                
            vwap_score, vwap_val, vwap_dist = calculate_long_term_vwap(amount, volume, current_price)
            if vwap_score > 0:
                score += vwap_score
                signals.append("VWAPæ”¯æ’‘")
            
            smooth_p = _kalman_filter_1d(close)
            
            macd, _, _ = talib.MACD(smooth_p.values)
            if detect_dynamic_divergence(smooth_p, pd.Series(macd)):
                score += SCORE_CRITERIA["macd_div"]
                signals.append("MACDåº•")
                
            rsi = talib.RSI(smooth_p.values, timeperiod=14)
            if detect_dynamic_divergence(smooth_p, pd.Series(rsi)):
                score += SCORE_CRITERIA["rsi_div"]
                signals.append("RSIåº•")
                
            v_score, v_rank = dynamic_volume_score(volume, mkt_cap)
            if v_score > 0:
                score += v_score
                signals.append(f"ç¼©é‡({int(v_rank*100)}%)")
                
            if hot_rank <= 20:
                ma60_val = ma60.iloc[-1] if not ma60.empty else current_price
                if current_price > ma60_val * 1.2:
                    score += SCORE_CRITERIA["heat_penalty"]
                    signals.append("é«˜ä½è¿‡çƒ­")
                elif current_price < ma60_val * 0.95:
                    score += SCORE_CRITERIA["heat_reversal"]
                    signals.append("ææ…Œèšæ°”")

            if score >= THRESHOLD_POTENTIAL:
                results.append({
                    "ä»£ç ": symbol,
                    "åç§°": name,
                    "ç°ä»·": current_price,
                    "è¯„åˆ†": round(score, 1),
                    "VWAPåç¦»": f"{vwap_dist*100:.1f}%",
                    "Alpha54": round(alpha_rank, 2),
                    "ä¿¡å·": "+".join(signals)
                })
                
        except Exception: continue

    df = pd.DataFrame(results)
    if not df.empty:
        df = df.sort_values(by="è¯„åˆ†", ascending=False)
        print(f"\nâš¡ æ‰«æç»“æŸã€‚ç†”æ–­æ‹¦æˆª {skipped_sector} åªæ‚æ¯›ï¼Œé€†åŠ¿æ•‘å› {rescued_dragon} åªé¾™å¤´ã€‚")
        print("\n" + "="*50)
        print(f"ğŸ† å±±è°·ç‹™å‡»ä¸¥é€‰æ¦œ (è¯„åˆ†>={THRESHOLD_HIGH_QUALITY})")
        print("="*50)
        high_q = df[df["è¯„åˆ†"] >= THRESHOLD_HIGH_QUALITY]
        if not high_q.empty:
            print(high_q.to_string(index=False))
        else:
            print("ï¼ˆæš‚æ— ç¬¦åˆä¸¥é€‰æ ‡å‡†çš„è‚¡ç¥¨ï¼‰")
            
        print("\n" + "-"*50)
        print(f"ğŸ“ˆ è§‚å¯Ÿæ±  (è¯„åˆ†>={THRESHOLD_POTENTIAL})")
        print("-"*50)
        pot = df[(df["è¯„åˆ†"] >= THRESHOLD_POTENTIAL) & (df["è¯„åˆ†"] < THRESHOLD_HIGH_QUALITY)]
        if not pot.empty:
            print(pot.head(20).to_string(index=False))
    else:
        print("âš ï¸ æœªå‘ç°ç¬¦åˆæ¡ä»¶çš„è‚¡ç¥¨ã€‚")

else:
    print("âŒ æ— æ³•è·å–å¸‚åœºæ•°æ®ã€‚")

ğŸ”¥ è¿½çƒ­åº¦ï¼šæ¿å—èµ„é‡‘é€‰è‚¡|import akshare as ak
import pandas as pd
import numpy as np
import time
import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed

# --- Helper Functions ---
def normalize(series):
    if series.empty: return series
    min_val = series.min()
    max_val = series.max()
    if max_val == min_val: return pd.Series([1.0]*len(series), index=series.index)
    return (series - min_val) / (max_val - min_val)

def get_rpp(close, high_60, low_60):
    if high_60 == low_60: return 0.5
    return (close - low_60) / (high_60 - low_60)

def _safe_vwap(amount, volume, current_price):
    """
    è‡ªé€‚åº”è®¡ç®— VWAPï¼Œè‡ªåŠ¨ä¿®æ­£ 'æ‰‹' vs 'è‚¡' çš„å•ä½é—®é¢˜
    """
    if volume == 0: return current_price
    
    # å°è¯•1: å‡è®¾å•ä½æ˜¯è‚¡
    raw_vwap = amount / volume
    
    # æ£€æŸ¥æ•°é‡çº§å·®å¼‚
    if current_price > 0:
        ratio = raw_vwap / current_price
        if 80 < ratio < 120: # åå·®çº¦100å€ï¼Œè¯´æ˜ Volume æ˜¯æ‰‹ (Amountæ˜¯å…ƒ, Volæ˜¯æ‰‹) -> éœ€é™¤ä»¥100
            return raw_vwap / 100.0
        elif 0.8 < ratio < 1.2: # åå·®ä¸å¤§ï¼Œè¯´æ˜ Volume æ˜¯è‚¡
            return raw_vwap
            
    # å…œåº•ï¼šå¦‚æœæ— æ³•åˆ¤æ–­ï¼Œå‡è®¾æ˜¯æ‰‹ï¼ˆAè‚¡ spot æ¥å£é€šå¸¸è¿”å›æ‰‹ï¼‰
    # ä½†ä¸ºäº†ä¿é™©ï¼Œè¿˜æ˜¯è¿”å›ä¿®æ­£åçš„
    return raw_vwap / 100.0 if raw_vwap > current_price * 50 else raw_vwap

def fetch_stock_data(code, name, sector):
    """
    Worker function to fetch data for a single stock.
    Returns dict or None.
    """
    try:
        # 1. Get Daily Data (for Trend & RPP)
        # We need historical data to calculate RPP (Relative Position)
        hist = ak.stock_zh_a_hist(symbol=code, period="daily", adjust="qfq")
        if hist is None or hist.empty or len(hist) < 60: return None
        
        last_row = hist.iloc[-1]
        close = last_row['æ”¶ç›˜']
        
        # RPP Calculation
        window_60 = hist.tail(60)
        high_60 = window_60['æœ€é«˜'].max()
        low_60 = window_60['æœ€ä½'].min()
        rpp = get_rpp(close, high_60, low_60)
        
        # Trend: Price > MA20
        ma20 = window_60['æ”¶ç›˜'].tail(20).mean()
        
        return {
            "code": code,
            "name": name,
            "sector": sector,
            "close": close,
            "rpp": rpp,
            "ma20": ma20,
            "vol_prev": last_row['æˆäº¤é‡']
        }
    except:
        return None

# --- Main Logic ---

print("ğŸ”¥ å¯åŠ¨ V2.0 æ¿å—èµ„é‡‘é€‰è‚¡å¼•æ“...")
start_time = time.time()

# 1. è·å–çƒ­é—¨æ¿å— (Real-time)
try:
    sectors = ak.stock_board_industry_name_em()
    if sectors is not None and not sectors.empty:
        # è¿‡æ»¤æ‰ ST æ¿å—
        sectors = sectors[~sectors['æ¿å—åç§°'].str.contains("ST")]
        # æŒ‰æ¶¨å¹…æ’åº
        top_sectors = sectors.sort_values(by="æ¶¨è·Œå¹…", ascending=False).head(8)
        sector_list = top_sectors['æ¿å—åç§°'].tolist()
        print(f"ğŸ¯ é”å®šçƒ­é—¨æ¿å—: {sector_list}")
    else:
        sector_list = []
except Exception as e:
    print(f"âŒ æ¿å—è·å–å¤±è´¥: {e}")
    sector_list = []

# 2. æ„å»ºå€™é€‰æ±  (Candidate Pool)
candidates = []
if sector_list:
    for sector in sector_list:
        try:
            cons = ak.stock_board_industry_cons_em(symbol=sector)
            if cons is not None and not cons.empty:
                for _, row in cons.iterrows():
                    candidates.append({
                        "code": str(row['ä»£ç ']), 
                        "name": row['åç§°'], 
                        "sector": sector
                    })
            time.sleep(0.2) # Avoid blocking
        except:
            continue

print(f"ğŸ” åˆå§‹å€™é€‰æ± : {len(candidates)} åªè‚¡ç¥¨")

# 3. å¹¶å‘è·å–æ•°æ® (Concurrent Fetching)
# é™åˆ¶æœ€å¤§çº¿ç¨‹æ•°ï¼Œé˜²æ­¢å°IP
MAX_WORKERS = 8 
analyzed_stocks = []

if candidates:
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {executor.submit(fetch_stock_data, c['code'], c['name'], c['sector']): c for c in candidates}
        
        for i, future in enumerate(as_completed(futures)):
            res = future.result()
            if res:
                analyzed_stocks.append(res)
            if i % 50 == 0:
                print(f"  è¿›åº¦: {i}/{len(candidates)}...")

print(f"\nâœ… æ•°æ®è·å–å®Œæˆï¼Œæœ‰æ•ˆè‚¡ç¥¨: {len(analyzed_stocks)}")

# 4. å®æ—¶è¡Œæƒ…æ ¡éªŒ (The Filter)
# ä¸ºäº†è·å–æœ€æ–°çš„ Price, Open, VWAP (Amount/Vol)ï¼Œæˆ‘ä»¬éœ€è¦æ‹‰å–ä¸€æ¬¡å…¨å¸‚åœº Spot
print("ğŸ“¡ æ‹‰å–å…¨å¸‚åœºå®æ—¶å¿«ç…§...")
try:
    spot_df = ak.stock_zh_a_spot_em()
    if spot_df is not None and not spot_df.empty:
        spot_df['ä»£ç '] = spot_df['ä»£ç '].astype(str)
    else:
        spot_df = pd.DataFrame()
except:
    print("âŒ å®æ—¶è¡Œæƒ…å¤±è´¥")
    spot_df = pd.DataFrame()

final_list = []
if not spot_df.empty and analyzed_stocks:
    # è½¬ä¸ºå­—å…¸åŠ é€ŸæŸ¥æ‰¾
    spot_map = spot_df.set_index('ä»£ç ').to_dict('index')
    
    for stock in analyzed_stocks:
        code = stock['code']
        if code not in spot_map: continue
        
        real = spot_map[code]
        
        # --- æ ¸å¿ƒè¿‡æ»¤é€»è¾‘ V2.0 ---
        
        try:
            current_price = float(real.get('æœ€æ–°ä»·', 0))
            open_price = float(real.get('ä»Šå¼€', 0))
            prev_close = float(real.get('æ˜¨æ”¶', 0))
            high_price = float(real.get('æœ€é«˜', 0))
            volume = float(real.get('æˆäº¤é‡', 0))
            amount = float(real.get('æˆäº¤é¢', 0))
            turnover = float(real.get('æ¢æ‰‹ç‡', 0))
            lb = float(real.get('é‡æ¯”', 0))
        except:
            continue
            
        if current_price == 0: continue
        
        # 1. ç›¸å¯¹ä½ç½® RPP < 0.4 (ä½ä½)
        if stock['rpp'] >= 0.4: continue
        
        # 2. è¶‹åŠ¿æ”¯æ’‘ (ä»·æ ¼ > MA20)
        # if current_price < stock['ma20']: continue 
        
        # 3. å®æ—¶å¼ºåº¦ (Price > Open) -> æ‹’ç»å‡é˜´çº¿
        if current_price <= open_price: continue
        
        # 4. èµ„é‡‘å®é”¤ (Price > VWAP)
        # ä½¿ç”¨è‡ªé€‚åº” VWAP è®¡ç®—ï¼Œé˜²æ­¢å•ä½é™·é˜±
        if volume > 0:
            vwap = _safe_vwap(amount, volume, current_price)
            if current_price < vwap: continue
            
            # V2.1 ä¼˜åŒ–ï¼šä¹–ç¦»ç‡é™åˆ¶ < 1.5%
            # é˜²æ­¢è¿½é«˜æ¥ç›˜
            vwap_dev = (current_price - vwap) / vwap
            if vwap_dev > 0.015: continue
            
        # 5. é‡èƒ½ç¡®è®¤ (é‡æ¯” > 1.2 æˆ– æ¢æ‰‹ > 1%)
        if lb < 1.2: continue
        
        # 6. é£æ§ï¼šæ‹’ç»æ¶¨åœ (Limit Up)
        if current_price >= prev_close * 1.095: continue
        
        # 7. æ¶¨å¹…åŒºé—´ (1% < Chg < 6%)
        chg_pct = (current_price - prev_close) / prev_close * 100
        if chg_pct < 1.0 or chg_pct > 6.0: continue
        
        # --- è¯„åˆ†ç³»ç»Ÿ ---
        # ä½ä½åˆ† (30) + èµ„é‡‘åˆ† (40) + å¼ºåº¦åˆ† (30)
        score_pos = (1 - stock['rpp']) * 30
        score_fund = min(lb / 3.0, 1.0) * 40
        score_mom = min(chg_pct / 5.0, 1.0) * 30
        
        total_score = score_pos + score_fund + score_mom
        
        stock['æœ€æ–°ä»·'] = current_price
        stock['æ¶¨è·Œå¹…'] = chg_pct
        stock['é‡æ¯”'] = lb
        stock['VWAP'] = round(vwap, 2)
        stock['è¯„åˆ†'] = int(total_score)
        
        # ç‚¹è¯„ç”Ÿæˆ
        comments = []
        if stock['rpp'] < 0.1: comments.append("æä½ä½")
        elif stock['rpp'] < 0.3: comments.append("ç›¸å¯¹åº•éƒ¨")
        
        if current_price > vwap * 1.01: comments.append("ç«™ç¨³å‡ä»·")
        if lb > 2.0: comments.append(f"æ”¾é‡{lb}å€")
        
        stock['ç‚¹è¯„'] = ",".join(comments)
        
        final_list.append(stock)

# 5. è¾“å‡ºç»“æœ
df = pd.DataFrame(final_list)
if not df.empty:
    df = df.sort_values(by="è¯„åˆ†", ascending=False).head(30)
    # æ ¼å¼åŒ–è¾“å‡º
    out_cols = ['code', 'name', 'sector', 'æœ€æ–°ä»·', 'æ¶¨è·Œå¹…', 'é‡æ¯”', 'rpp', 'è¯„åˆ†', 'ç‚¹è¯„']
    df = df[out_cols]
    df.columns = ['ä»£ç ', 'åç§°', 'æ¿å—', 'æœ€æ–°ä»·', 'æ¶¨è·Œå¹…', 'é‡æ¯”', 'RPPä½ç½®', 'ç»¼åˆè¯„åˆ†', 'ç‚¹è¯„']
    
    print("\nğŸ† æœ€ç»ˆç²¾é€‰ (Top 30):")
    # print(df.to_string()) 

# å¿…é¡»èµ‹å€¼ç»™ df å˜é‡ä¾›ç³»ç»Ÿè¯»å–
df = df if not df.empty else pd.DataFrame(columns=['ä»£ç ', 'åç§°', 'ç‚¹è¯„'])
print(f"è€—æ—¶: {time.time() - start_time:.2f}s")

æ´—ç›˜æ‹‰å‡çªç ´|
import akshare as ak
import pandas as pd
import numpy as np
import datetime
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import Counter
import threading

# ==========================================
# ç­–ç•¥é…ç½® (å‚æ•°å¾®è°ƒ)
# ==========================================
MIN_PRICE_RISE = 2.0        
MIN_VOL_RATIO = 1.5         
WASH_DAYS_WINDOW = 10       
WASH_LOW_DAYS_REQ = 5       
TURNOVER_QUANTILE = 0.20    
MAX_SHADOW_RATIO = 0.35     # æ–°å¢ï¼šå…è®¸çš„æœ€å¤§ä¸Šå½±çº¿æ¯”ä¾‹
MAX_OPEN_GAP_PCT = 5.0
MARKET_PANIC_PCT = -1.0
MARKET_INDEX_SYMBOL = "sh000300"
MARKET_FAST_MA = 20
MARKET_SLOW_MA = 60
MARKET_SLOPE_DAYS = 5

_stats_lock = threading.Lock()
_stats = Counter()

def _stat_inc(key: str, n: int = 1):
    with _stats_lock:
        _stats[key] += int(n)

def _get_core_index_pct_changes():
    indices = None
    try:
        indices = ak.stock_zh_index_spot_em()
    except Exception:
        indices = None
    if indices is None or indices.empty:
        frames = []
        for sym in ["æ ¸å¿ƒæŒ‡æ•°", "æŒ‡æ•°æˆä»½", "ä¸Šè¯ç³»åˆ—æŒ‡æ•°", "æ·±è¯ç³»åˆ—æŒ‡æ•°"]:
            try:
                df = ak.stock_zh_index_spot_em(symbol=sym)
                if df is not None and not df.empty:
                    frames.append(df)
            except Exception:
                continue
        if frames:
            indices = pd.concat(frames, ignore_index=True, copy=False).drop_duplicates()
    if indices is None or indices.empty:
        return {}
    if "åç§°" not in indices.columns:
        return {}
    pct_col = "æ¶¨è·Œå¹…" if "æ¶¨è·Œå¹…" in indices.columns else None
    if pct_col is None:
        return {}
    targets = ["ä¸Šè¯æŒ‡æ•°", "åˆ›ä¸šæ¿æŒ‡"]
    out = {}
    filtered = indices[indices["åç§°"].isin(targets)]
    for _, row in filtered.iterrows():
        try:
            out[str(row["åç§°"])] = float(row[pct_col])
        except Exception:
            continue
    return out

def _get_market_regime_state(index_symbol: str = MARKET_INDEX_SYMBOL):
    try:
        df = ak.stock_zh_index_daily_em(symbol=index_symbol)
    except Exception:
        return True, {}
    if df is None or df.empty or "close" not in df.columns:
        return True, {}
    df = df.tail(260).copy()
    df["close"] = pd.to_numeric(df["close"], errors="coerce")
    df = df.dropna(subset=["close"]).reset_index(drop=True)
    if len(df) < (MARKET_SLOW_MA + MARKET_SLOPE_DAYS + 5):
        return True, {}

    df["ma_fast_prev"] = df["close"].rolling(MARKET_FAST_MA).mean().shift(1)
    df["ma_slow_prev"] = df["close"].rolling(MARKET_SLOW_MA).mean().shift(1)
    df["ma_fast_slope"] = df["ma_fast_prev"] - df["ma_fast_prev"].shift(MARKET_SLOPE_DAYS)
    df["pct_change"] = df["close"].pct_change() * 100

    last = df.iloc[-1]
    ok = (
        (last["close"] > last["ma_fast_prev"])
        and (last["ma_fast_prev"] > last["ma_slow_prev"])
        and (last["ma_fast_slope"] > 0)
        and (last["pct_change"] > MARKET_PANIC_PCT)
    )
    info = {
        "symbol": index_symbol,
        "date": str(df["date"].iloc[-1]) if "date" in df.columns else None,
        "close": float(last["close"]) if pd.notna(last["close"]) else None,
        "pct_change": float(last["pct_change"]) if pd.notna(last["pct_change"]) else None,
        "ma_fast_prev": float(last["ma_fast_prev"]) if pd.notna(last["ma_fast_prev"]) else None,
        "ma_slow_prev": float(last["ma_slow_prev"]) if pd.notna(last["ma_slow_prev"]) else None,
        "ma_fast_slope": float(last["ma_fast_slope"]) if pd.notna(last["ma_fast_slope"]) else None,
    }
    return bool(ok), info

def analyze_stock_optimized(args):
    """
    åˆ†æå•åªè‚¡ç¥¨ (ä¼˜åŒ–ç‰ˆ)
    args: (symbol, name) å…ƒç»„ï¼Œæ–¹ä¾¿å¤šçº¿ç¨‹ä¼ å‚
    """
    symbol, name = args
    _stat_inc("analyze_called")
    
    # 0. åŸºç¡€é£æ§ï¼šå‰”é™¤ ST å’Œ é€€å¸‚æ•´ç†
    if "ST" in name or "é€€" in name:
        _stat_inc("skip_st")
        return None

    try:
        # 1. è·å–æ•°æ® (å¢åŠ ç®€å•çš„é‡è¯•æœºåˆ¶é€»è¾‘)
        end_date = datetime.datetime.now().strftime("%Y%m%d")
        # åªéœ€è¦è¿‡å» ~150 å¤©æ•°æ®å³å¯è®¡ç®— MA60 å’Œå‰é¢çš„æ´—ç›˜
        start_date = (datetime.datetime.now() - datetime.timedelta(days=150)).strftime("%Y%m%d")
        
        # å¢åŠ é‡è¯•æœºåˆ¶
        df = None
        for _ in range(3):
            try:
                df = ak.stock_zh_a_hist(symbol=symbol, period="daily", start_date=start_date, end_date=end_date, adjust="qfq")
                if df is not None and not df.empty:
                    break
            except:
                time.sleep(0.5)
        
        if df is None or df.empty or len(df) < 65: # ç¨å¾®å¤šç•™ä¸€ç‚¹buffer
            _stat_inc("skip_insufficient_daily")
            return None
            
        # 2. å•ä½é˜²å¾¡ (ä¿ç•™ Ratio Check é€»è¾‘)
        if df['æˆäº¤é‡'].iloc[-1] > 0:
            last_close = df['æ”¶ç›˜'].iloc[-1]
            last_vol = df['æˆäº¤é‡'].iloc[-1]
            last_amt = df['æˆäº¤é¢'].iloc[-1]
            # Raw_VWAP = Amount / Volume. å¦‚æœ Raw_VWAP / Price â‰ˆ 100ï¼Œè¯´æ˜ Volume æ˜¯æ‰‹
            if (last_amt / last_vol) / last_close >= 80:
                df['æˆäº¤é‡'] = df['æˆäº¤é‡'] * 100
        
        # 3. æŒ‡æ ‡è®¡ç®—
        df['pct_chg'] = df['æ¶¨è·Œå¹…']
        df['turnover'] = df['æ¢æ‰‹ç‡']
        df['ma20'] = df['æ”¶ç›˜'].rolling(20).mean()
        df['ma60'] = df['æ”¶ç›˜'].rolling(60).mean()
        df['vol_ma5'] = df['æˆäº¤é‡'].rolling(5).mean()
        
        # 4. æ ¸å¿ƒé€»è¾‘åˆ¤å®š
        curr = df.iloc[-1]
        prev_close = df["æ”¶ç›˜"].iloc[-2]
        
        # A. è¶‹åŠ¿å…±æŒ¯ (æ–°å¢ä¼˜åŒ–)
        # è¦æ±‚ MA60 å‘ä¸Š (ä»Šæ—¥ MA60 > 5æ—¥å‰ MA60) ä¸” æ”¶ç›˜ä»· > MA60
        ma60_slope_up = curr['ma60'] > df['ma60'].iloc[-5]
        is_trend_up = (curr['æ”¶ç›˜'] > curr['ma60']) and ma60_slope_up
        
        if not is_trend_up:
            _stat_inc("skip_trend")
            return None

        # B. æ´—ç›˜æ£€æµ‹ (ä¿ç•™åŸæœ‰é€»è¾‘)
        turnover_threshold = df['turnover'].rolling(60).quantile(TURNOVER_QUANTILE)
        df['is_low_turnover'] = df['turnover'] < turnover_threshold
        # shift(1) æ’é™¤ä»Šæ—¥ï¼Œæ£€æŸ¥ä¹‹å‰ N å¤©
        wash_count = df['is_low_turnover'].shift(1).rolling(WASH_DAYS_WINDOW).sum().iloc[-1]
        
        if wash_count < WASH_LOW_DAYS_REQ:
            _stat_inc("skip_wash")
            return None
            
        # C. çˆ†å‘ä¿¡å· (Trigger)
        # ä¿®æ­£ï¼šå¯¹æ¯”æ˜¨æ—¥å‡é‡ï¼ˆä¸å«ä»Šæ—¥ï¼‰ï¼Œå› ä¸ºä»Šæ—¥çš„å·¨é‡ä¼šæ‹‰é«˜ MA5ï¼Œå¯¼è‡´åˆ¤å®šå¤±æ•ˆ
        # ä½¿ç”¨ shift(1) è·å–æ˜¨æ—¥çš„ vol_ma5 (å³å‰5å¤©å‡é‡)
        # æ³¨æ„ï¼šdf['vol_ma5'] = df['æˆäº¤é‡'].rolling(5).mean()
        # æ‰€ä»¥ df['vol_ma5'].iloc[-2] å°±æ˜¯æ˜¨æ—¥ç®—å‡ºæ¥çš„è¿‡å»5å¤©å‡é‡ (T-1, T-2, T-3, T-4, T-5)
        # æˆ–è€…ç›´æ¥å– shift(1).iloc[-1]
        
        vol_ma5_yesterday = df['vol_ma5'].shift(1).iloc[-1]
        if pd.isna(vol_ma5_yesterday) or vol_ma5_yesterday == 0:
            _stat_inc("skip_vol_ma_na")
            return None
            
        is_vol_spike = curr['æˆäº¤é‡'] > (vol_ma5_yesterday * 1.5)
        is_price_rise = curr['pct_chg'] > MIN_PRICE_RISE
        is_above_ma20 = curr['æ”¶ç›˜'] > curr['ma20']
        open_pct_change = (curr["å¼€ç›˜"] - prev_close) / prev_close * 100 if prev_close and prev_close > 0 else 999.0
        is_safe_open = open_pct_change < MAX_OPEN_GAP_PCT
        
        # D. å½¢æ€ä¼˜åŒ–ï¼šä¸Šå½±çº¿æ§åˆ¶ (æ›¿ä»£çº¯ç²¹çš„ Close near High)
        # ä¸Šå½±çº¿é•¿åº¦ / (æœ€é«˜ - æœ€ä½)
        high_low_range = curr['æœ€é«˜'] - curr['æœ€ä½']
        if high_low_range == 0:
            upper_shadow_ratio = 0
        else:
            upper_shadow_ratio = (curr['æœ€é«˜'] - curr['æ”¶ç›˜']) / high_low_range
            
        is_solid_close = upper_shadow_ratio < MAX_SHADOW_RATIO
        
        if is_vol_spike and is_price_rise and is_above_ma20 and is_solid_close and is_safe_open:
            _stat_inc("signal_hit")
            # è®¡ç®—å»ºè®®æ­¢æŸä½ (ä¾‹å¦‚ï¼šä»Šæ—¥å¼€ç›˜ä»· æˆ– MA20)
            stop_loss = max(curr['å¼€ç›˜'], curr['ma20'])
            
            return {
                "ä»£ç ": symbol,
                "åç§°": name,
                "ç°ä»·": curr['æ”¶ç›˜'],
                "æ¶¨è·Œ%": curr['pct_chg'],
                "é‡æ¯”": round(curr['æˆäº¤é‡'] / curr['vol_ma5'], 2),
                "æ¢æ‰‹%": curr['turnover'],
                "æ´—ç›˜å¼ºåº¦": f"{int(wash_count)}/{WASH_DAYS_WINDOW}",
                "MA60è¶‹åŠ¿": "å‘ä¸Š" if ma60_slope_up else "èµ°å¹³",
                "å»ºè®®æ­¢æŸ": round(stop_loss, 2),
                "ä»Šå¼€%": round(float(open_pct_change), 2),
                "ä¿¡å·": "æ´—ç›˜çªç ´"
            }
        else:
            if not is_vol_spike:
                _stat_inc("fail_vol_spike")
            if not is_price_rise:
                _stat_inc("fail_price_rise")
            if not is_above_ma20:
                _stat_inc("fail_above_ma20")
            if not is_solid_close:
                _stat_inc("fail_solid_close")
            if not is_safe_open:
                _stat_inc("fail_safe_open")
            
    except Exception:
        _stat_inc("error_exception")
        return None
    return None

def run_strategy():
    print("ğŸš€ å¯åŠ¨å¤šçº¿ç¨‹é€‰è‚¡ç­–ç•¥ (ä¼˜åŒ–ç‰ˆ)...")
    with _stats_lock:
        _stats.clear()
    
    # 1. è·å– Spot æ•°æ®
    try:
        df_market = ak.stock_zh_a_spot_em()
    except Exception as e:
        print(f"âŒ ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•è·å–å®æ—¶è¡Œæƒ…: {e}")
        return pd.DataFrame(columns=["ä»£ç ", "åç§°", "ç°ä»·", "æ¶¨è·Œ%", "é‡æ¯”", "æ´—ç›˜å¼ºåº¦", "MA60è¶‹åŠ¿", "å»ºè®®æ­¢æŸ", "ä¿¡å·"])

    idx_pct = _get_core_index_pct_changes()
    sh = idx_pct.get("ä¸Šè¯æŒ‡æ•°")
    cyb = idx_pct.get("åˆ›ä¸šæ¿æŒ‡")
    if sh is not None and cyb is not None and (sh <= MARKET_PANIC_PCT) and (cyb <= MARKET_PANIC_PCT):
        print(f"âš ï¸ å¤§ç›˜ç¯å¢ƒåå¼±ï¼šä¸Šè¯{sh:.2f}% åˆ›ä¸šæ¿{cyb:.2f}%")
        return pd.DataFrame(columns=["ä»£ç ", "åç§°", "ç°ä»·", "æ¶¨è·Œ%", "é‡æ¯”", "æ´—ç›˜å¼ºåº¦", "MA60è¶‹åŠ¿", "å»ºè®®æ­¢æŸ", "ä¿¡å·"])

    market_ok, market_info = _get_market_regime_state()
    if not market_ok:
        info = market_info or {}
        date = info.get("date") or ""
        close = info.get("close")
        pct = info.get("pct_change")
        ma_fast = info.get("ma_fast_prev")
        ma_slow = info.get("ma_slow_prev")
        sym = info.get("symbol") or MARKET_INDEX_SYMBOL
        msg_parts = [f"{sym} {date}".strip()]
        if close is not None and pct is not None:
            msg_parts.append(f"close={close:.2f} pct={pct:.2f}%")
        if ma_fast is not None and ma_slow is not None:
            msg_parts.append(f"MA{MARKET_FAST_MA}={ma_fast:.2f} MA{MARKET_SLOW_MA}={ma_slow:.2f}")
        print("âš ï¸ å¤§ç›˜ç¯å¢ƒè¿‡æ»¤ï¼š" + " | ".join([p for p in msg_parts if p]))
        return pd.DataFrame(columns=["ä»£ç ", "åç§°", "ç°ä»·", "æ¶¨è·Œ%", "é‡æ¯”", "æ´—ç›˜å¼ºåº¦", "MA60è¶‹åŠ¿", "å»ºè®®æ­¢æŸ", "ä¿¡å·"])

    # 2. åˆç­› (è¿‡æ»¤æ‰åœç‰Œã€è·Œåœã€æ— é‡ä¸ªè‚¡)
    mask = (df_market['æœ€æ–°ä»·'] > 0) & \
           (df_market['æˆäº¤é‡'] > 0) & \
           (df_market['æ¶¨è·Œå¹…'] > MIN_PRICE_RISE) # å¿…é¡»ä¸Šæ¶¨
           
    # å¦‚æœæœ‰é‡æ¯”å­—æ®µï¼Œå…ˆç­›ä¸€ä¸‹ï¼Œå‡å°‘è¯·æ±‚é‡
    if 'é‡æ¯”' in df_market.columns:
        mask = mask & (df_market['é‡æ¯”'] > 1.2) # æ”¾å®½ä¸€ç‚¹ç»™åé¢å†å²æ•°æ®ç¡®è®¤
        
    targets = df_market[mask][['ä»£ç ', 'åç§°']].values.tolist()
    print(f"ğŸ” åˆç­›åå¾…åˆ†æ: {len(targets)} åªè‚¡ç¥¨")

    results = []
    
    # 3. å¤šçº¿ç¨‹å¹¶å‘æ‰§è¡Œ (å¤§å¹…æå‡é€Ÿåº¦)
    # max_workers å»ºè®®è®¾ä¸º 10-20ï¼Œå¤ªé«˜å®¹æ˜“è¢«å°æ¥å£
    start_time = time.time()
    with ThreadPoolExecutor(max_workers=16) as executor:
        # æäº¤ä»»åŠ¡
        future_to_stock = {executor.submit(analyze_stock_optimized, t): t for t in targets}
        
        # å¤„ç†è¿›åº¦æ¡
        total_tasks = len(targets)
        completed = 0
        
        for future in as_completed(future_to_stock):
            res = future.result()
            if res:
                results.append(res)
            
            completed += 1
            if completed % 20 == 0:
                print(f"è¿›åº¦: {completed}/{total_tasks}...", end="\r")
                
    elapsed = time.time() - start_time
    print(f"\nâ±ï¸ è€—æ—¶: {elapsed:.2f}ç§’")
    with _stats_lock:
        if _stats:
            print("ğŸ“Š è¿‡æ»¤ç»Ÿè®¡:", dict(_stats))

    # 4. è¾“å‡º
    if results:
        df_res = pd.DataFrame(results)
        # æŒ‰é‡æ¯”å’Œæ¶¨å¹…ç»¼åˆæ’åº
        # æ³¨æ„ï¼šæ´—ç›˜å¼ºåº¦æ˜¯å­—ç¬¦ä¸² "5/10"ï¼Œæ’åºå¯èƒ½ä¸å‡†ï¼Œå…ˆè½¬æ•°å€¼
        df_res['æ´—ç›˜å¤©æ•°'] = df_res['æ´—ç›˜å¼ºåº¦'].apply(lambda x: int(x.split('/')[0]))
        df_res = df_res.sort_values(by=["æ´—ç›˜å¤©æ•°", "é‡æ¯”"], ascending=False)
        
        print("\nâœ… é€‰è‚¡ç»“æœ (æŒ‰æ´—ç›˜è´¨é‡æ’åº)ï¼š")
        cols = ["ä»£ç ", "åç§°", "ç°ä»·", "æ¶¨è·Œ%", "ä»Šå¼€%", "é‡æ¯”", "æ¢æ‰‹%", "æ´—ç›˜å¼ºåº¦", "MA60è¶‹åŠ¿", "å»ºè®®æ­¢æŸ"]
        print(df_res[cols].to_string(index=False))
        return df_res
    else:
        print("\nâš ï¸ ä»Šæ—¥æ— ç¬¦åˆæ¡ä»¶çš„æ ‡çš„")
        return pd.DataFrame(columns=["ä»£ç ", "åç§°", "ç°ä»·", "æ¶¨è·Œ%", "é‡æ¯”", "æ¢æ‰‹%", "æ´—ç›˜å¼ºåº¦", "MA60è¶‹åŠ¿", "å»ºè®®æ­¢æŸ", "ä¿¡å·"])

# æ‰§è¡Œç­–ç•¥
# æ³¨æ„ï¼šåœ¨ screener_service ä¸­æ‰§è¡Œæ—¶ï¼Œéœ€è¦å°†ç»“æœèµ‹å€¼ç»™ df å˜é‡
df = run_strategy()

